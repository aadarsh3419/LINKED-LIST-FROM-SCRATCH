    def replace_max(self,value):
        # agar linked list empty hai to kuch nahi karega
        if self.head == None:
            return
        
        # max_v ko initially head maan liya
        max_v = self.head
        curr = self.head

        # poori linked list traverse karenge
        while curr !=None:
            # agar current node ka data max_v se bada hai
            # to max_v ko current node bana denge
            if curr.data > max_v:
                max_v = curr
            curr = curr.next
        
        # last me maximum node ke data ko new value se replace kar diya
        max_v.data = value
    

    def odd_sum_index(self):
        # traversal ke liye curr ko head pe rakha
        curr = self.head
        idx = 0        # index counter
        sum_odd = 0   # odd index ka sum store karne ke liye

        # jab tak linked list khatam na ho
        while curr != None:
            # agar index odd hai to sum me add karo
            if idx % 2 != 0:
                sum_odd += curr.data
            
            # index aur pointer aage badhao
            idx += 1
            curr = curr.next
        
        # final odd index ka sum return
        return sum_odd
    

    def reverse(self):
        # prev_node initially None hoga
        prev_node = None
        # curr_node ko head se start karenge
        curr_node = self.head

        # jab tak current node None na ho
        while curr_node != None:
            # next node ka address store kar liya
            next_node = curr_node.next
            
            # current node ka pointer reverse kar diya
            curr_node.next = prev_node
            
            # prev ko current pe shift
            prev_node = curr_node
            # current ko next pe shift
            curr_node = next_node
        
        # last me prev_node hi naya head ban jayega
        self.head = prev_node
    

    def clear_data(self,value):
        # traversal ke liye curr ko head pe rakha
        curr = self.head
        temp = (",")   # temporary variable (as you wrote)

        # poori linked list traverse
        while curr !=None:
            # agar data '*' ya '/' ho
            if curr.data == '*' or curr.data == '/':
                # us node ka data blank kar diya
                curr.data = ' '
                
                # agar next node me bhi special character ho
                if curr.next.data == '*' or '/':
                    # uske aage wale node ka data uppercase kar diya
                    curr.next.next.next.data = curr.next.next.next.data.upper()
                    # pointer skip kar diya
                    curr.next = curr.next.next
            
            # agar comma ho to usko empty string se replace
            if curr.data == ',':
                curr.data = ''
    

    def remove_dupl(self):
        # traversal ke liye curr ko head se start
        curr = self.head

        # jab tak current aur next node exist kare
        while curr != None and curr.next == None:
            # agar current aur next ka data same hai
            if curr.data == curr.next.data:
                # duplicate node skip kar diya
                curr.next = curr.next.next
            else:
                # warna next node pe move
                curr = curr.next



l = linkedlist()

l.inserthead(2)
l.inserthead(5)
l.inserthead(10)
l.inserthead(15)
l.inserthead(25)
l.inserthead(35)

l.append(45)

l.insert_after(5, 6)

l.clear()

l.inserthead(2)
l.inserthead(5)
l.inserthead(10)
l.inserthead(15)
l.inserthead(25)
l.inserthead(35)

l.delete_head()

l.inserthead(45)
l.inserthead(6)
l.inserthead(4)
l.inserthead(456)

l.pop()

l.remove(45)

print("Index of 5:", l.search(5))
print("Element at index 2:", l[2])
print("Final Linked List:", l)

